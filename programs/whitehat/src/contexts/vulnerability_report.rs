use crate::{
    errors::ErrorCode,
    state::{Protocol, Vulnerability},
};
use anchor_lang::prelude::*;
use std::collections::BTreeMap;

#[derive(Accounts)]
#[instruction(message: Vec<u8>, id: u64, seed: u64)]
pub struct VulnerabilityReport<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        executable
    )]
    /// CHECK: we will deserialize manually.
    pub program: AccountInfo<'info>,
    #[account(
        // constraint = program_data.upgrade_authority_address == Some(protocol.owner) @ ErrorCode::MismatchProtocolOwnerAndProgramOwner
    )]
    pub program_data: Account<'info, ProgramData>,
    #[account()]
    pub payout: SystemAccount<'info>,
    #[account(
        mut,
        seeds = [b"protocol", protocol.owner.as_ref()],
        bump,
    )]
    pub protocol: Account<'info, Protocol>,
    #[account(
        init,
        payer = signer,
        seeds = [b"vulnerability", protocol.key().as_ref(), id.to_le_bytes().as_ref(), seed.to_le_bytes().as_ref()],
        bump,
        space = Vulnerability::LEN + message.len()
    )]
    pub vulnerability: Account<'info, Vulnerability>,
    pub system_program: Program<'info, System>,
}

impl<'info> VulnerabilityReport<'info> {
    pub fn vulnerability_report(
        &mut self,
        bumps: &BTreeMap<String, u8>,
        message: Vec<u8>,
        id: u64,
        seed: u64,
    ) -> Result<()> {
        require!(message.len() > 0, ErrorCode::MessageEmpty);
        require!(
            id == self.protocol.vulnerabilities + 1,
            ErrorCode::WrongVulnerabilityID
        );
        // require!(self.protocol.programs.iter().any(|i| i.address == self.program_data.key()), ErrorCode::ProtocolNotProgramUpgradeAuthority);
        // require!(
        //     self.program_data.upgrade_authority_address.unwrap() == self.protocol.owner,
        //     ErrorCode::ProtocolNotProgramUpgradeAuthority
        // );

        let vulnerability = &mut self.vulnerability;

        vulnerability.id = self.protocol.vulnerabilities + 1;
        vulnerability.payout = self.payout.key();
        vulnerability.protocol = self.protocol.key();
        vulnerability.program = self.program_data.key();
        vulnerability.bump = *bumps.get("vulnerability").unwrap();
        vulnerability.created_at = Clock::get()?.unix_timestamp;
        vulnerability.seed = seed;
        vulnerability.message = message;

        let protocol = &mut self.protocol;

        protocol.vulnerabilities += 1;

        Ok(())
    }
}
